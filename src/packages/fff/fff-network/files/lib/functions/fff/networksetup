# Copyright 2019 Adrian Schmutzler
# License GPLv3

. /lib/functions/network.sh

setAutoConf() {
	# Sets ipv6 auto configuration on an interface to on/off
	# Usage: setAutoConf <interface> <[0|1]>
	local iface=$1
	local on=$2

	sysctlfile="/etc/sysctl.d/51-fff-network-$iface.conf"
	echo "# Generated from configurenetwork" > "$sysctlfile"
	echo "net.ipv6.conf.$iface.accept_ra = $on" >> "$sysctlfile"
	echo "net.ipv6.conf.$iface.accept_ra_defrtr = $on" >> "$sysctlfile"
	echo "net.ipv6.conf.$iface.accept_ra_pinfo = $on" >> "$sysctlfile"
	echo "net.ipv6.conf.$iface.autoconf = $on" >> "$sysctlfile"
	echo "net.ipv6.conf.$iface.accept_ra_rtr_pref = $on" >> "$sysctlfile"
	echo "net.ipv6.conf.$iface.forwarding = 0" >> "$sysctlfile"

	/sbin/sysctl -p "$sysctlfile"
}

enableAutoConf() {
	# Enables ipv6 auto configuration on an interface
	# Usage: enableAutoConf <interface>
	local iface=$1

	setAutoConf "$iface" "1"
}

disableAutoConf() {
	# Disables ipv6 auto configuration on an interface
	# Usage: disableAutoConf <interface>
	local iface=$1

	setAutoConf "$iface" "0"
}

fixMac() {
	# Update MAC address on live device/interface
	#
	# fixMac <newmac> <interface>
	#
	# newmac: MAC address to be set
	# interface: Interface to be updated as in uci (e.g. mesh)

	local newmac=$1
	local iface=$2
	local dev

	echo "Fixing MAC on $iface"
	sleep 10

	network_get_physdev dev "$iface"

	uci set "network.${iface}.macaddr=$newmac"
	uci commit network

	if [ -n "$dev" ]; then
		ip link set "$dev" down
		ip link set "$dev" address "$newmac"
		ip link set "$dev" up
	fi

	/etc/init.d/network restart
}

setupSwitch() {
	# Set up switch for switch-based devices
	# This is intended for initial setup, not for updates
	# (changing ports will be sufficient then)
	#
	# Usage: setupSwitch <CLIENT_PORTS> <BATMAN_PORTS> [<WAN_PORTS>]

	local CLIENT_PORTS=$1
	local BATMAN_PORTS=$2
	local WAN_PORTS=$3

	uci set "network.vlan1.ports=$CLIENT_PORTS"

	# This defines the VLAN for WAN ports inside the switch.
	# This is required even if the WAN eth is separate, but the WAN port is in the switch!
	if [ -n "$WAN_PORTS" ]; then
		uci set "network.vlan2.ports=$WAN_PORTS"
	fi

	uci set "network.vlan3.ports=$BATMAN_PORTS"

	local MESHIF="$(uci get network.lan.ifname | grep -o -m1 "eth\d")"
	uci set network.ethmesh.ifname="$MESHIF.3"
}

setupOnePort() {
	# Set up port mode for non-switch port
	#
	# For two-port devices without switch just call this twice:
	# setupOnePort "WAN" eth0
	# setupOnePort "BATMAN" eth1
	#
	# Indivual change of a single port is also supported now!
	#
	# Usage: setupOnePort <ETHMODE, e.g. BATMAN, CLIENT, WAN> [<DEV, default: eth0>]

	local ETHMODE=$1
	local DEV=$2
	local MESH

	[ -n "$DEV" ] || DEV=eth0

	if [ "$ETHMODE" = "WAN" ]; then
		uci set network.wan=interface
		uci set network.wan.ifname="$DEV"
		uci set network.wan.proto=dhcp
		enableAutoConf "$DEV"
	elif uci -q get network.wan.ifname | grep "^ *$DEV *$"; then
		# only disable WAN for $DEV if it was set before
		# -> will ignore other eth if called for second port
		uci del network.wan.ifname
		disableAutoConf "$DEV"
	fi

	MESH="$(uci -q get network.mesh.ifname | sed "s/\b$DEV //" | sed "s/ *$DEV$//g")"
	if [ "$ETHMODE" = "CLIENT" ]; then
		if [ -n "$MESH" ]; then
			uci set network.mesh.ifname="$MESH $DEV"
		else
			uci set network.mesh.ifname="$DEV"
		fi
	else
		uci set network.mesh.ifname="$MESH"
	fi

	if [ "$ETHMODE" = "BATMAN" ]; then
		# Always overwrite (if both ports are set to BATMAN, only the last will be)
		uci set network.ethmesh.ifname="$DEV"
	elif uci -q get network.ethmesh.ifname | grep "^ *$DEV *$"; then
		uci del network.ethmesh.ifname
	fi

	uci commit network
}

switchPrefix() {
	# Returns ethX. of switch, e.g. "eth0."
	#
	# This requires at least one switch_vlan being present and network to be initialized

	ls /sys/class/net/ | grep -m1 -o "^eth\d\."
}
